Redis单线程！！
	1、基于内存
	2、非阻塞IO
	3、避免了多线程间切换的竞态消耗
	
#######################################################
key(字符串)-value（值的类型）

字符串 set key value | get key
hash   hset hget   map<key,value> 
list集合  底层 链表的实现 
set集合 无序 且不重复 集合
zset集合 有序 且不重复的集合 集合中的每一个元素关联了一个分数。根据分数升序排序！！

五种数据类型必须掌握 常用的命令浏览下！！

bitmaps ：
String字符串类型。提供了对字符串类型的值的位操作 bit oprators   010101010

#######################################################

del key
exists key
type key
ttl（s）/pttl（ms） 查看key的有效时间还剩多少
keys * 
设置key的存活时间
	expire key 秒数
	pexpire key 毫秒数
移除有效时间
	persist key 
	
	
到了给定的过期时间就会删除？？
怎么删除？？ Redis怎么就知道当前的key过期了。 
1、主动删除
		用户使用的时候才会删除。
		expire key 100
		
		get key  检查有没有有效时间，有没有过期。如果过期，直接删除。
		
2、被动删除
	 有一个定时任务 每个一段时间查看redis中的key 检查过期时间 如果过期则直接删除！！ 每秒10次 100ms一次！！
	 不是全量的检查！！ 10万key！！ 随机抽查！！   每次随机20个  19个   20个 1个 0个  停止定时任务一段时间！！

expire key 100
过了100s后当前key一定不再redis中？？？？？


#######################################################

16G 内存
set 数据 

Redis吃满服务器的内存？？？？？

会！！    
配置 maxmemory？？ 8G   8.5G

7.8 

SET KEY VALUE 0.5g  此时就会超过最大内存


超过8G,怎么办？？

set 数据！！  内存淘汰策略！！
1、报错。不能写入数据！！
2、不报错。内存置换！！ 老的数据删除，腾出一些空间！！
		内存置换策略：
			lru：最近最少使用
			allkeys-
			volatile-
			
			random：随机
			allkeys-
			volatile-
			
			volatile-ttl：最少存活时间


#######################################################
Redis持久化
redis存储基于内存？？？   意外宕机！！ 内存中的数据100%的丢失！！

两种方式
	1、RDB快照(默认方式)
		在某个时机，将redis中的所有数据，快照，生成一个.rdb二进制文件。这个文件包含当前redis缓存中的所有数据。
		
		如何恢复数据：Redis服务重启的时候，加载.rdb二进制数据文件。将全部数据重写加载到Redis中。
		
		何时执行：redis的配置文件中配置规则 
					满足条件 自动触发
					 #save 执行RDB快照的命令
						save 900 1   在900秒内，大于等于1个增删改(影响数据)的命令执行。就会执行save快照,进行持久化
						save 300 10  在300秒内，大于等于10个增删改(影响数据)的命令执行。就会执行save快照,进行持久化
						save 60 10000 在60秒内，大于等于10000个增删改(影响数据)的命令执行。就会执行save快照,进行持久化 
						     time  num   在time秒内，大于等于num个增删改(影响数据)的命令执行。就会执行RDB持久化
					手动执行：
						save  ：阻塞redis ，redis此时不能执行其他命令。  
						bgsave：	fork子线程。使用这个子线程去执行持久化任务。不会阻塞Redis。
					发送shutdown命令，正常关闭redis。redis在关闭前，执行save命令，进行一个持久化！！
		
		
		
	2、AOF文件追加
		将客户端执行的命令(增删改)进行保存，保存到.aof后缀名的文件。包含了所有客户端的增删改的命令。
		
		如何恢复数据：读取.aof文件,重新依次执行aof文件中的所有命令。原封不动的执行原来的命令。数据跟原来也是一样！！
		
		何时执行：默认没有开启，首先需要开启aof持久化
						appendonly no(不开启，默认值) | yes(开启)
						
						# appendfsync always  每执行一次命令，将该命令写入.aof文件中。   1条 风险极地  性能影响会很大！！
						appendfsync everysec  每秒钟 将用户执行的命令从操作系统缓存中写入到.aof文件中。 
						# appendfsync no      由操作系统决定什么时候将命令写入.aof文件中。什么时候将操作系统缓存中的命令写入到.aof文件中。
						
						用户在执行redis命令的时候，这些命令缓存在操作系统的缓存中。


												AOF     vs 				RDB
持久化文件大小					大								小
恢复数据的速度					慢								快
丢失数据的风险					小								大					虽然做了持久化，但是不能100%保证不丢失数据


redis持久化。可以保证，基本不会丢失数据，即使丢失也只是丢失部分数据！！
磁盘  ---> 服务器炸了！！！！
定期备份aof/rdb文件。  ----> 云服务器( 百度云、阿里云  )  容灾！！

############################################################


